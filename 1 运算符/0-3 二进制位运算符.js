/*
 * @Description: 二进制位运算符
 * @Author: WaynePeng
 * @Date: 2020-02-01 16:18:34
 * @LastEditTime : 2020-02-01 18:54:51
 * @LastEditors  : WaynePeng
 */
// 二进制位运算符用于直接对二进制位进行计算 (有一点需要特别注意，位运算符只对整数起作用，如果一个运算子不是整数，会自动转为整数后再执行。另外，虽然在 JavaScript 内部，数值都是以64位浮点数的形式储存，但是做位运算的时候，是以32位带符号的整数进行运算的，并且返回值也是一个32位带符号的整数)

// 1. 二进制或运算符 (|) (二进制或运算符（|）逐位比较两个运算子，两个二进制位之中只要有一个为1，就返回1，否则返回0)
console.log('######### 二进制或运算符 #########')
console.log(5 | 0) // 5
// 5 -> 101
// 0 -> 000
// b -> 101 -> 3
console.log(3 | 7) // 7
// 3 -> 011
// 7 -> 111
// b -> 111 -> 7
// 因为二进制位运算的结果是一个32位带符号的整数，可以利用这个特性将数值转换位32位整数，大于32位的位数都会被舍弃
function toInt32(x) {
  return x | 0
}
console.log(toInt32(3.14)) // 3 // 直接取整，而非四舍五入
console.log('1a' | 123) // 123 // 对于无法直接转换为数字的字符串返回数字的运算子
console.log('1a' | '2a') // 0 // 如果都不能转换为数字则返回0

// 2. 二进制与运算符 (&)（二进制与运算符（&）的规则是逐位比较两个运算子，两个二进制位之中只要有一个位为0，就返回0，否则返回1）
console.log('######## 二进制与运算符 ########')
console.log(5 & 0) // 0
// 5 -> 101
// 0 -> 000
// b -> 000 -> 0
console.log(3 & 7) // 3
// 3 -> 011
// 7 -> 111
// b -> 011 -> 3

// 3. 二进制否运算符 (~) (二进制否运算符（~）将每个二进制位都变为相反值（0变为1，1变为0)
// 可以简单记忆成，一个数与自身的取反值相加，等于-1
console.log('######## 二进制否运算符 ########')
console.log(~3) // -4
// 上面表达式对3进行二进制否运算，得到-4。之所以会有这样的结果，是因为位运算时，JavaScript 内部将所有的运算子都转为32位的二进制整数再进行运算。

// 3的32位整数形式是00000000000000000000000000000011，二进制否运算以后得到11111111111111111111111111111100。由于第一位（符号位）是1，所以这个数是一个负数。JavaScript 内部采用补码形式表示负数，即需要将这个数减去1，再取一次反，然后加上负号，才能得到这个负数对应的10进制值。这个数减去1等于11111111111111111111111111111011，再取一次反得到00000000000000000000000000000100，再加上负号就是-4。考虑到这样的过程比较麻烦，可以简单记忆成，一个数与自身的取反值相加，等于-1

// 3 + x = -1 -> x = -4
console.log(~9) // -10 // -10 + 9 = -1

// 对一个整数连续两次二进制否运算，得到它自身
console.log(~~7) // 7
// 同样的，我们可以利用这一特性给对小数进行32位取整 (使用二进制否运算取整，是所有取整方法中最快的一种)
function toInteger32(x) {
  return ~~x
}
console.log(toInteger32(3.99)) // 3
 console.log(~'123') // -124 // 等同于 -> ~Number('123') -> -124
 console.log(~'1a') // -1 // 等同于 - > ~Number('1a') -> ~NaN -> -1

 // 相当于 ~Number([])
~[] // -1
// 相当于 ~Number(NaN)
~NaN // -1
// 相当于 ~Number(null)
~null // -1

// 4. 异或运算符 (^) (异或运算（^）在两个二进制位不同时返回1，相同时返回0)
console.log('######### 异或运算符 #########')
console.log(5 ^ 0) // 5
// 5 -> 101
// 0 -> 000
// b -> 101 -> 5
console.log(3 ^ 7) // 4
// 3 -> 011
// 7 -> 111
// b -> 100 -> 4
// “异或运算”有一个特殊运用，连续对两个数a和b进行三次异或运算，a^=b; b^=a; a^=b;，可以互换它们的值。这意味着，使用“异或运算”可以在不引入临时变量的前提下，互换两个变量的值 (这是互换两个变量的值的最快方法)
let a = 3
let b = 7
a ^= b
b ^= a
a ^= b
console.log(a) // 7
console.log(b) // 3
// 解析
// 第一次 a ^= b
// a 3 -> 011
// b 7 -> 111
// a值 -> 100 -> 4
// 第二次 b ^= a
// a 4 -> 100
// b 7 -> 111
// b值 -> 011 -> 3
// 第三次 a ^= b
// a 4 -> 100
// b 3 -> 011
// a值 -> 111 -> 7

// 同样的 ^ 也可以用来取整
function tI32(x) {
  return x ^ 0
}
console.log(tI32(2.88)) // 2

// 5. 左移运算符 (<<) (左移运算符（<<）表示将一个数的二进制值向左移动指定的位数，尾部补0，即乘以2的指定次方。向左移动的时候，最高位的符号位是一起移动的)
console.log('########## 左移运算符 #########')
console.log(5 << 1) //10
// 5 -> 101
// 5 << 1 -> 1010 -> 10
// 利用 << 的规则也可以用来取整
console.log(5.12 << 0) // 5
console.log(-5.12 << 0) // -5

// 6. 右移运算符 (>>) (右移运算符（>>）表示将一个数的二进制值向右移动指定的位数。如果是正数，头部全部补0；如果是负数，头部全部补1。右移运算符基本上相当于除以2的指定次方（最高位即符号位参与移动) 
console.log('######## 右移运算符 ########')
console.log(5 >> 1) // 2
// 5 -> 101
// 5 >> 1 -> 10 -> 2
// 也可以理解为 5 / 2 = 2

// 7. 头部补零的右移运算符 (>>>) 头部补零的右移运算符（>>>）与右移运算符（>>）只有一个差别，就是一个数的二进制形式向右移动时，头部一律补零，而不考虑符号位。所以，该运算总是得到正值。对于正数，该运算的结果与右移运算符（>>）完全一致，区别主要在于负数
console.log('########## 头部补零的右移运算符 ##########')

console.log(5 >>> 1) // 2
console.log(-5 >>> 1) // 2147483645
// >>> 是查看负数在计算机中储存形式最快的方式
console.log((-5 >>> 0).toString(2)) // 11111111111111111111111111111011
